#!/usr/bin/env python3

import os
import sys
import glob
import base64
import shutil
import getpass
import argparse
import sqlite3
import hashlib
import logging
import datetime
import pyotp
from rich.console import Console
from rich.table import Table
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend

logging.basicConfig(filename='encryptnotes.log', level=logging.INFO)
console = Console()

home = os.path.expanduser("~")
db_dir = os.path.join(home, 'Documents', 'Database')
db_path = os.path.join(db_dir, 'encryptnotes.db')
if not os.path.exists(db_dir):
    os.makedirs(db_dir)

conn = sqlite3.connect(db_path)
conn.execute('''
CREATE TABLE IF NOT EXISTS notes (
  id INTEGER PRIMARY KEY,
  timestamp TEXT NOT NULL,
  salt BLOB NOT NULL,
  encrypted_note BLOB NOT NULL,
  hashed_pass BLOB NOT NULL
)
''')
conn.execute('''
CREATE TABLE IF NOT EXISTS tags (
  id INTEGER PRIMARY KEY,
  note_id INTEGER NOT NULL,
  tag TEXT NOT NULL,
  FOREIGN KEY(note_id) REFERENCES notes(id)
)
''')
conn.execute('''
CREATE TABLE IF NOT EXISTS user2fa (
  id INTEGER PRIMARY KEY,
  secret TEXT NOT NULL
)
''')
conn.commit()

def backup_database():
    bk = os.path.join(db_dir, f'backup_{datetime.datetime.now().strftime("%Y%m%d_%H%M%S")}.db')
    try:
        shutil.copy2(db_path, bk)
        console.print(f"[bold green]Backup created at {bk}[/bold green]")
        logging.info(f"Backup at {bk}")
    except:
        console.print("[bold red]Backup failed[/bold red]")
        logging.error("Backup failed")

def derive_key(password, salt):
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100000, backend=default_backend())
    return kdf.derive(password.encode())

def encrypt_data(data, key):
    return Fernet(base64.urlsafe_b64encode(key)).encrypt(data.encode())

def decrypt_data(data, key):
    return Fernet(base64.urlsafe_b64encode(key)).decrypt(data).decode()

def setup_2fa():
    c = conn.execute('SELECT secret FROM user2fa').fetchone()
    if c:
        console.print("[bold yellow]2FA is already set up[/bold yellow]")
        return
    s = pyotp.random_base32()
    conn.execute('INSERT INTO user2fa (secret) VALUES (?)', (s,))
    conn.commit()
    uri = pyotp.totp.TOTP(s).provisioning_uri(name='EncryptNotes', issuer_name='SecureApp')
    console.print(f"[bold green]Scan this QR code URI in your 2FA app:\n{uri}[/bold green]")

def verify_2fa():
    c = conn.execute('SELECT secret FROM user2fa').fetchone()
    if not c:
        return True
    code = getpass.getpass("Enter 2FA code: ")
    return pyotp.TOTP(c[0]).verify(code)

def add_note():
    if not verify_2fa():
        console.print("[bold red]2FA failed[/bold red]")
        return
    note = input("\nEnter note: ")
    pwd = getpass.getpass("Password: ")
    cfm = getpass.getpass("Confirm: ")
    if pwd != cfm:
        console.print("[bold red]Passwords do not match[/bold red]")
        return
    salt = os.urandom(16)
    key = derive_key(pwd, salt)
    enc = encrypt_data(note, key)
    hsh = hashlib.sha256(pwd.encode()).digest()
    t = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    conn.execute('INSERT INTO notes (timestamp, salt, encrypted_note, hashed_pass) VALUES (?,?,?,?)',(t,salt,enc,hsh))
    conn.commit()
    idx = conn.execute('SELECT last_insert_rowid()').fetchone()[0]
    tg = input("Tags (comma separated): ").split(',')
    for tag in tg:
        tag = tag.strip()
        if tag:
            conn.execute('INSERT INTO tags (note_id, tag) VALUES (?,?)',(idx, tag))
    conn.commit()
    console.print("[bold green]Note added[/bold green]")
    logging.info(f"Note {idx} added")

def list_notes():
    cur = conn.execute('SELECT id,timestamp FROM notes')
    table = Table(title="Notes")
    table.add_column("ID")
    table.add_column("Timestamp")
    for r in cur:
        table.add_row(str(r[0]), r[1])
    console.print(table)
    idx = input("Enter ID to view (0=back): ")
    if not idx.isdigit() or idx == '0':
        return
    if not verify_2fa():
        console.print("[bold red]2FA failed[/bold red]")
        return
    row = conn.execute('SELECT salt,encrypted_note,hashed_pass FROM notes WHERE id=?',(idx,)).fetchone()
    if not row:
        console.print("[bold red]Not found[/bold red]")
        return
    pwd = getpass.getpass("Password: ")
    if hashlib.sha256(pwd.encode()).digest() != row[2]:
        console.print("[bold red]Wrong password[/bold red]")
        return
    try:
        dec = decrypt_data(row[1], derive_key(pwd, row[0]))
    except:
        console.print("[bold red]Decryption error[/bold red]")
        return
    console.print(f"[bold cyan]\nNote {idx}[/bold cyan]\n{dec}\n")
    console.print("1=Edit 2=Delete 3=Export 4=Back")
    o = input("> ")
    if o=='1':
        edit_note(idx, pwd, row[0], row[1], row[2])
    elif o=='2':
        delete_note(idx)
    elif o=='3':
        p = input("Path (empty=current dir): ")
        if not p:
            p = f"note_{idx}.txt"
        try:
            with open(p,'w') as f:
                f.write(dec)
            console.print(f"[bold green]Exported to {p}[/bold green]")
            logging.info(f"Note {idx} exported to {p}")
        except Exception as e:
            console.print(f"[bold red]{e}[/bold red]")
    else:
        return

def edit_note(idx, old_pwd, salt, enc, hsh):
    note_current = decrypt_data(enc, derive_key(old_pwd, salt))
    new_content = input("New content: ")
    console.print("1=Append 2=Replace")
    c = input("> ")
    if c=='1':
        updated = note_current + "\n" + new_content
    elif c=='2':
        updated = new_content
    else:
        return
    npwd = getpass.getpass("New password (empty=keep same): ")
    if not npwd:
        k = derive_key(old_pwd, salt)
        hh = hsh
        s = salt
    else:
        cfm = getpass.getpass("Confirm new: ")
        if npwd != cfm:
            console.print("[bold red]Mismatch[/bold red]")
            return
        s = os.urandom(16)
        k = derive_key(npwd, s)
        hh = hashlib.sha256(npwd.encode()).digest()
    new_enc = encrypt_data(updated, k)
    conn.execute('UPDATE notes SET salt=?, encrypted_note=?, hashed_pass=? WHERE id=?',(s,new_enc,hh,idx))
    conn.commit()
    console.print("[bold green]Updated[/bold green]")
    logging.info(f"Note {idx} updated")

def delete_note(idx):
    if not verify_2fa():
        console.print("[bold red]2FA failed[/bold red]")
        return
    conn.execute('DELETE FROM notes WHERE id=?',(idx,))
    conn.execute('DELETE FROM tags WHERE note_id=?',(idx,))
    conn.commit()
    console.print(f"[bold green]Note {idx} deleted[/bold green]")
    logging.info(f"Note {idx} deleted")

def import_txt(pattern):
    if not verify_2fa():
        console.print("[bold red]2FA failed[/bold red]")
        return
    if os.path.isdir(pattern):
        pattern = os.path.join(pattern,"*.txt")
    files = glob.glob(pattern)
    if not files:
        console.print("[bold red]No files[/bold red]")
        return
    content = []
    for fp in sorted(files):
        decs = ['utf-8','latin-1','ISO-8859-1','windows-1252']
        data = None
        for d in decs:
            try:
                with open(fp,'r',encoding=d) as f:
                    data = f.read()
                break
            except:
                pass
        if data:
            content.append(data)
    joined = "\n\n".join(content).strip()
    if not joined:
        console.print("[bold red]Failed decode[/bold red]")
        return
    console.print("[bold yellow]Importing as single note[/bold yellow]")
    pwd = getpass.getpass("Password: ")
    cfm = getpass.getpass("Confirm: ")
    if pwd != cfm:
        console.print("[bold red]Passwords do not match[/bold red]")
        return
    salt = os.urandom(16)
    key = derive_key(pwd, salt)
    enc = encrypt_data(joined, key)
    hsh = hashlib.sha256(pwd.encode()).digest()
    t = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    conn.execute('INSERT INTO notes (timestamp, salt, encrypted_note, hashed_pass) VALUES (?,?,?,?)',(t,salt,enc,hsh))
    idx = conn.execute('SELECT last_insert_rowid()').fetchone()[0]
    conn.commit()
    console.print("[bold green]Imported[/bold green]")
    logging.info(f"Note {idx} imported")

def search_note(args):
    if len(args)<2:
        console.print("[bold red]Usage: -s <id> <terms>[/bold red]")
        return
    try:
        idx = int(args[0])
    except:
        console.print("[bold red]Invalid ID[/bold red]")
        return
    if not verify_2fa():
        console.print("[bold red]2FA failed[/bold red]")
        return
    row = conn.execute('SELECT salt,encrypted_note,hashed_pass FROM notes WHERE id=?',(idx,)).fetchone()
    if not row:
        console.print("[bold red]Not found[/bold red]")
        return
    pwd = getpass.getpass("Password: ")
    if hashlib.sha256(pwd.encode()).digest() != row[2]:
        console.print("[bold red]Wrong password[/bold red]")
        return
    try:
        dec = decrypt_data(row[1], derive_key(pwd, row[0]))
    except:
        console.print("[bold red]Decryption error[/bold red]")
        return
    combos = [
        "".join(args[1:]),
        "".join(args[:0:-1]),
        ".".join(args[1:]),
        ".".join(args[:0:-1])
    ]
    found = False
    for c in combos:
        if c in dec:
            found = True
            console.print(f"[bold green]Match for '{c}'[/bold green]")
            for line in dec.split("\n"):
                if c in line:
                    console.print(line)
    if not found:
        console.print("[bold yellow]No matches[/bold yellow]")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-n','--new',action='store_true')
    parser.add_argument('-i','--importfile',type=str)
    parser.add_argument('-s','--search',nargs='+')
    parser.add_argument('--setup-2fa',action='store_true')
    parser.add_argument('--backup',action='store_true')
    args = parser.parse_args()
    if args.setup_2fa:
        setup_2fa()
        return
    if args.backup:
        backup_database()
        return
    if args.new:
        add_note()
        return
    if args.importfile:
        import_txt(args.importfile)
        return
    if args.search:
        search_note(args.search)
        return
    while True:
        console.print("""
[bold cyan]
1 - New note
2 - Import .txt
3 - List notes
4 - Setup 2FA
5 - Backup
6 - Exit
[/bold cyan]
""")
        o = input("> ")
        if o=='1':
            add_note()
        elif o=='2':
            p = input("Path: ")
            import_txt(p)
        elif o=='3':
            list_notes()
        elif o=='4':
            setup_2fa()
        elif o=='5':
            backup_database()
        elif o=='6':
            break
        else:
            console.print("[bold red]Invalid option[/bold red]")

if __name__=='__main__':
    try:
        main()
        conn.close()
    except KeyboardInterrupt:
        console.print("\n[bold red]Interrupted[/bold red]")
        conn.close()
        sys.exit()
